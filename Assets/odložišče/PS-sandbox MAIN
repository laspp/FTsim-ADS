//ButtonsDebouncer();
//ledTest();
//actuators();

// 1 RED LIGHT
	IO.LEDRed := IO.ButtonRed;

// 2 RED AND GREEN LIGHT
	IO.LEDGreen := IO.ButtonGreen;

// 3 PRODUCTION START
	IO.MotorCompressor := IO.SwitchCompressor;

// 5 EDGE DETECTION
	IF NOT buttonOldValue AND IO.ButtonBlackLeftDown THEN
		buttonRisingEdge := TRUE;
	END_IF
	
	IF buttonRisingEdge THEN
		timerButton_TP(IN := TRUE, PT:= T#2S);
		buttonRisingEdge := FALSE;
	ELSE
		timerButton_TP(IN := FALSE);
	END_IF
	
	//commented because of 6
	//IO.LEDBlueDown := timerButtonTP.Q;
	
	//update old value
	buttonOldValue := IO.ButtonBlackLeftDown;
	
// 6 TON and TOF TIMERS
	IF IO.ButtonBlackLeftDown THEN
		timer_TOF(IN := TRUE, PT := T#3S);
		timer_TON(IN := TRUE, PT := T#2S);
	ELSE
		timer_TOF(IN := FALSE);
		timer_TON(IN := FALSE);
	END_IF
	
	IO.LEDBlueUp := timer_TOF.Q;
	IO.LEDBlueDown := timer_TON.Q;

// 8 ENTRY PISTON (MANUAL)	
	IF IO.ToggleSwitch THEN
		IO.ValveEntryForward := IO.ButtonBlackRightUp;
		IO.ValveEntryBackward := IO.ButtonBlackLeftUp;
	END_IF

// 9 ENTRY PISTON (AUTO)
IF NOT IO.ToggleSwitch THEN
	IF photocelOldValue AND NOT IO.PhotocellEntry THEN
		photoCellFalingEdge := TRUE;
	END_IF	
		
	IF photoCellFalingEdge AND NOT IO.PhotocellEntry THEN
		timerDelay_TON(IN := TRUE, PT := T#1S);
	ELSE
		timerDelay_TON(in := FALSE);
	END_IF
	
	IF timerDelay_TON.Q THEN
		photoCellFalingEdge := FALSE;
		timerMoveEntryPistonF_TP(IN := TRUE, PT := T#3S);
	ELSE
		timerMoveEntryPistonF_TP(IN := FALSE);	 
	END_IF
	
	IF timerMoveEntryPistonF_TP.Q THEN
		IO.valveEntryForward := TRUE;
	ELSE
		IO.valveEntryForward := FALSE;
	END_IF

	//update old value
	photocelOldValue := IO.PhotocellEntry;
	
// 10 RETURN ENTRY PISTON
	IF timerMoveEntryPistonOldValue AND NOT timerMoveEntryPistonF_TP.Q THEN
		timerMoveEntryPistonFallingEdge := TRUE;
	END_IF	
			
	IF timerMoveEntryPistonFallingEdge THEN
		timerMoveEntryPistonFallingEdge := FALSE;
		timerMoveEntryPistonB_TP(IN := TRUE, PT := T#3S);
		//this two rows needed for 11
		tablepostionCount := 0;
		addToCount := TRUE;
	ELSE
		timerMoveEntryPistonB_TP(IN := FALSE);
	END_IF
	
	IF timerMoveEntryPistonB_TP.Q THEN
		IO.ValveEntryBackward := TRUE;
	ELSE
		IO.ValveEntryBackward := FALSE;
	END_IF
	
	//update old value
	timerMoveEntryPistonOldValue := timerMoveEntryPistonF_TP.Q;
	
// 11 ROTATE TABLE
	IF addToCount AND NOT SwitchTablePositionOldValue AND IO.SwitchTablePosition THEN
		tablepostionCount := tablepostionCount + 1;
	END_IF
	
	IF addToCount AND tablepostionCount < 2 THEN
		IO.MotorTableMovement := TRUE;
	ELSE
		IO.MotorTableMovement := FALSE;
	END_IF

	//safety switch
	IF IO.SwitchTableExit THEN
		IO.MotorTableMovement := FALSE;
		addToCount := FALSE;
	END_IF
	
	//update old value
	SwitchTablePositionOldValue := IO.SwitchTablePosition;


// 12 MACHINE WORK
//	IF IO.SwitchMachine THEN 
//		timerMachine_TP(IN := TRUE, PT := T#5S);
//	ELSE
//		timerMachine_TP(IN := FALSE);
//	END_IF

//	IF timerMachine_TP.Q THEN
//		IO.MotorTableMovement := FALSE;
//		IO.ValveMachine := IO.ButtonBlackRightDown;
//	END_IF
	
// 13 EXIT PISTON (AUTO)
	IF tablepostionCount = 2 THEN
		timerMoveExitPistonF_TOF(IN := TRUE, PT := T#3S);
		tablepostionCount := 0;
		addToCount := FALSE;
	ELSE
		timerMoveExitPistonF_TOF(IN := FALSE);
	END_IF
	
	//if only one timer is managinf the exit, we can avoid if statements
	IO.ValveExitForward := timerMoveExitPistonF_TOF.Q; 
	
	IF moveExitPistonOldValue AND NOT timerMoveExitPistonF_TOF.Q THEN
		moveExitPistonFallingEdge := TRUE;
	END_IF
	
	IF moveExitPistonFallingEdge THEN
		timerMoveExitPistonB_TOF(IN := TRUE, PT := T#3S);
	ELSE
		timerMoveExitPistonB_TOF(IN := FALSE);
	END_IF
	
	IO.ValveExitBackward := timerMoveExitPistonB_TOF.Q; 
	
	//update old value
	moveExitPistonOldValue := timerMoveExitPistonF_TOF.Q;
	
// 14 BELT MOVEMENT
	IF moveExitPistonFallingEdge THEN
		moveExitPistonFallingEdge := FALSE;
		// timer for 15
		timerBeltTimeout_TOF(IN := TRUE, PT := T#5S);
		runBelt := TRUE;
	ELSE
		timerBeltTimeout_TOF(IN := FALSE);
	END_IF
	
	//less code with this apporach
	IO.MotorBeltMovement := runBelt; 
	
	IF NOT IO.PhotocellExit THEN
		//runBelt := FALSE;
		// modification for 16
		IF NOT alreadyMovedWorkpiece THEN
			alreadyMovedWorkpiece := TRUE;
			timerBeltMoveLittle_TP(IN := TRUE, PT := T#1.5S);
		ELSE
			runBelt := FALSE;
			//timerBeltMoveLittle_TOF(IN := FALSE);
		END_IF
		
	END_IF
	//	alternative
	//	IF runBelt AND IO.PhotocellExit THEN
	//		IO.MotorBeltMovement := TRUE;
	//	ELSE
	//		runBelt := FALSE;
	//		IO.MotorBeltMovement := FALSE;
	//	END_IF
	
// 15 BELT TIMEOUT
	IF beltTimeoutOldValue AND NOT timerBeltTimeout_TOF.Q THEN
		runBelt := FALSE;
		IO.MotorBeltMovement := FALSE;
	END_IF
	
	//update old value
	beltTimeoutOldValue := timerBeltTimeout_TOF.Q;
	
// 16
//	IF beltMoveLittleOldValue AND NOT timerBeltMoveLittle_TP.Q THEN
//		runBelt := FALSE;
//	END_IF
	
//	//update old value
//	beltMoveLittleOldValue := timerBeltMoveLittle_TP.Q;
	
END_IF // IF NOT IO.ToggleSwitch THEN 